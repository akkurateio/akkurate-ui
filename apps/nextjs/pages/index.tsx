import { Heading, VStack } from "@chakra-ui/react"
import { useState } from "react"
// @ts-ignore
import { NovelEditor } from "@akkurateio/novel"
import axios from "axios"
import DrawerAddTicket from "../app/components/DrawerAddTicket"
import TicketAnswerDescription from "../app/components/TicketAnswerDescription"

export const handleUpload = async (
  file: File | undefined | null,
  withToast = false,
): Promise<{
  tmpPath: string
  originalName: string
  ok: boolean
}> => {
  if (!file) {
    return Promise.resolve({ tmpPath: "", originalName: "", ok: false })
  }

  return axios
    .post("/api/upload", {
      fileName: file.name,
      fileType: file.type,
    })
    .then(async (res) => {
      const upload = await fetch(res.data.url, {
        method: "PUT",
        body: file,
        headers: { "Content-Type": file.type },
      })

      if (upload.ok) {
        return { tmpPath: res.data.path, originalName: file.name, ok: true }
      } else {
        return { tmpPath: "", originalName: "", ok: false }
      }
    })
    .catch((err) => {
      console.error(err)
      return { tmpPath: "", originalName: "", ok: false }
    })
}
export const addTipMedia = (data: {
  name: string
  media: {
    tmpPath: string
    originalName: string
    ok?: boolean
  }
}) => {
  return axios
    .post("http://notable.test/api/v1/tip-medias", data, {
      headers: {
        Authorization: `Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJhdWQiOiI3NTM3MmNkNi0xNDk0LTQ1M2ItYTcwMC1iNjRjZDhmZWJkOTMiLCJqdGkiOiJlNmRiODIxMmY5NTM3ZWU4N2QxMzdhNTBmMmE0ZGU4OGQxYTJhMGYwNWZmMWI1ZmU4ZTVhZjM1YjM0YjQyYmM1MDJjMzRkZjNkOTJhNGU2ZiIsImlhdCI6MTY5MDg5OTY3Mi4xMzA2ODQsIm5iZiI6MTY5MDg5OTY3Mi4xMzA2ODYsImV4cCI6MTY5MDk4NjA3MS40NzgzMzQsInN1YiI6IjI1Iiwic2NvcGVzIjpbXX0.U78XKyUX0WXPcGv7M_ogPdbHWzNns9lu9E4kjBT8YRWwCFV3IIpbyOZl_R3Q8ltXOK7DY_kebqClmvjO8Ugb0qTKeR7uzLk_rp4Z8kWKMYYC0oghuGFEURcHpdGomO6Pvi_UU0DERMxJNcrUEu-MFggwURCs6HWgvNlGRans5rj2vuLzWKTYQuOq-BoYlavmV7FzH4eCyqCdtBw9HKZye4l5NQvtQtiSevWT6Cd2LtuUc4nAcVpk396EgBbOekf587mbfHuZKJOINrcIK-V7b7DFJt6iSlltafTFJBw5nI7soOJYd7e5DQtUrVm_8OGNtceqmCMaLaA5nDA7QfGySdTm-ApQ8AISHdAk_MyaXAsURfMft5nUcOQx5DNZ382qWi7ERoPCq1vBvK9llJYb8S0__ijB-WlURaWXRVhFaRZI0lRQeomBL913EyCFcigALl-F1zX3OnUM7nixhZ8vAqjrHGIlUvOiTBEJ2Rtn7KstrXjASFuy5_rZweHyDVmNrAKdJ2J3wrclygmpzm1PmQRe0Gt8t-XI-XdkRxEXVPh9HV4GFCMd13uHnacRf-tjGqDAm14ltRE_1rsvLPrtmIQOdFWzp0h5LZCrkzDt5zbf9kvk3ytOj9t_L4-exTwUp0Q0E2Fdi6yq_NLwu0W9xljJ7g8dPdQ_kJsyDPIXxIs`,
      },
    })
    .then((res) => res.data)
}
const handleFileUpload = async (file: File | null = null) => {
  if (!file) {
    return
  }

  // file?.map(async (f) => {
  const myFile = await handleUpload(file)

  if (!myFile.ok) {
    throw new Error("Error uploading file")
  }

  const data = await addTipMedia({
    name: file.name,
    media: myFile,
  }).then((data) => {
    return data
  })

  return {
    ...data.data,
    url: data.data.url.thumbnail_large_url,
  }
}
function App() {
  const [htmlValue, setHtmlValue] = useState<string>("")

  const dateStyles = {
    arrowColor: "teal.400",
    hoverBg: "green.300",
    hoverColor: "green.900",
    selectedBg: "green.800",
    selectedColor: "green.100",
    otherMonthBg: "transparent",
    otherMonthColor: "green.700",
    currentMonthBg: "green.100",
    currentMonthColor: "green.700",
    disabledBg: "gray.200",
    disabledColor: "gray.700",
    //
    isResetable: false,
    isOtherMonthVisible: true,
    isCloseOnSelect: true,
  }

  const [value, setValue] = useState(`
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<?xml encoding='utf-8' ?><html><body><h2><a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#introduction">Introduction</a></h2><p>Laravel includes Eloquent, an object-relational mapper (ORM) that makes it enjoyable to interact with your database. When using Eloquent, each database table has a corresponding "Model" that is used to interact with that table. In addition to retrieving records from the database table, Eloquent models allow you to insert, update, and delete records from the table as well.</p><blockquote><img src="https://laravel.com/img/callouts/lightbulb.min.svg"><p>Before getting started, be sure to configure a database connection in your application's <code>config/database.php</code> configuration file. For more information on configuring your database, check out <a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/database#configuration">the database configuration documentation</a>.</p></blockquote><h4><strong>Laravel Bootcamp</strong></h4><p>If you're new to Laravel, feel free to jump into the <a target="_blank" rel="noopener noreferrer nofollow" href="https://bootcamp.laravel.com/">Laravel Bootcamp</a>. The Laravel Bootcamp will walk you through building your first Laravel application using Eloquent. It's a great way to get a tour of everything the Laravel and Eloquent have to offer.</p><p></p><h2><a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#generating-model-classes">Generating Model Classes</a></h2><p>To get started, let's create an Eloquent model. Models typically live in the <code>app\\Models</code> directory and extend the <code>Illuminate\\Database\\Eloquent\\Model</code> class. You may use the <code>make:model</code> <a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/artisan">Artisan command</a> to generate a new model:</p><pre><code>php artisan make:model Flight</code></pre><p>If you would like to generate a <a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/migrations">database migration</a> when you generate the model, you may use the <code>--migration</code> or <code>-m</code> option:</p><pre><code>php artisan make:model Flight --migration</code></pre><p>You may generate various other types of classes when generating a model, such as factories, seeders, policies, controllers, and form requests. In addition, these options may be combined to create multiple classes at once:</p><pre><code># Generate a model and a FlightFactory class...</code></pre><p>php artisan make:model Flight --factory</p><p>php artisan make:model Flight -f</p><p>&nbsp;</p><p># Generate a model and a FlightSeeder class...</p><p>php artisan make:model Flight --seed</p><p>php artisan make:model Flight -s</p><p>&nbsp;</p><p># Generate a model and a FlightController class...</p><p>php artisan make:model Flight --controller</p><p>php artisan make:model Flight -c</p><p>&nbsp;</p><p># Generate a model, FlightController resource class, and form request classes...</p><p>php artisan make:model Flight --controller --resource --requests</p><p>php artisan make:model Flight -crR</p><p>&nbsp;</p><p># Generate a model and a FlightPolicy class...</p><p>php artisan make:model Flight --policy</p><p>&nbsp;</p><p># Generate a model and a migration, factory, seeder, and controller...</p><p>php artisan make:model Flight -mfsc</p><p>&nbsp;</p><p># Shortcut to generate a model, migration, factory, seeder, policy, controller, and form requests...</p><p>php artisan make:model Flight --all</p><p>&nbsp;</p><p># Generate a pivot model...</p><p>php artisan make:model Member --pivot</p><p>php artisan make:model Member -p</p><p></p><h4><a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#inspecting-models"><strong>Inspecting Models</strong></a></h4><p>Sometimes it can be difficult to determine all of a model's available attributes and relationships just by skimming its code. Instead, try the <code>model:show</code> Artisan command, which provides a convenient overview of all the model's attributes and relations:</p><pre><code>php artisan model:show Flight</code></pre><p></p><h2><a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#eloquent-model-conventions">Eloquent Model Conventions</a></h2><p>Models generated by the <code>make:model</code> command will be placed in the <code>app/Models</code> directory. Let's examine a basic model class and discuss some of Eloquent's key conventions:</p><pre><code>&lt;?php</code></pre><p>&nbsp;</p><p>namespace App\\Models;</p><p>&nbsp;</p><p>use Illuminate\\Database\\Eloquent\\Model;</p><p>&nbsp;</p><p>class Flight extends Model</p><p>{</p><p>// ...</p><p>}</p><p></p><h3><a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#table-names"><strong>Table Names</strong></a></h3><p>After glancing at the example above, you may have noticed that we did not tell Eloquent which database table corresponds to our <code>Flight</code> model. By convention, the "snake case", plural name of the class will be used as the table name unless another name is explicitly specified. So, in this case, Eloquent will assume the <code>Flight</code> model stores records in the <code>flights</code> table, while an <code>AirTrafficController</code> model would store records in an <code>air_traffic_controllers</code> table.</p><p>If your model's corresponding database table does not fit this convention, you may manually specify the model's table name by defining a <code>table</code> property on the model:</p><pre><code>&lt;?php</code></pre><p>&nbsp;</p><p>namespace App\\Models;</p><p>&nbsp;</p><p>use Illuminate\\Database\\Eloquent\\Model;</p><p>&nbsp;</p><p>class Flight extends Model</p><p>{</p><p>/**</p><p> * The table associated with the model.</p><p> *</p><p> * @var string</p><p>*/</p><p>protected $table = 'my_flights';</p><p>}</p><p></p><h3><a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#primary-keys"><strong>Primary Keys</strong></a></h3><p>Eloquent will also assume that each model's corresponding database table has a primary key column named <code>id</code>. If necessary, you may define a protected <code>$primaryKey</code> property on your model to specify a different column that serves as your model's primary key:</p><pre><code>&lt;?php</code></pre><p>&nbsp;</p><p>namespace App\\Models;</p><p>&nbsp;</p><p>use Illuminate\\Database\\Eloquent\\Model;</p><p>&nbsp;</p><p>class Flight extends Model</p><p>{</p><p>/**</p><p> * The primary key associated with the table.</p><p> *</p><p> * @var string</p><p>*/</p><p>protected $primaryKey = 'flight_id';</p><p>}</p><p>In addition, Eloquent assumes that the primary key is an incrementing integer value, which means that Eloquent will automatically cast the primary key to an integer. If you wish to use a non-incrementing or a non-numeric primary key you must define a public <code>$incrementing</code> property on your model that is set to <code>false</code>:</p><pre><code>&lt;?php</code></pre><p>&nbsp;</p><p>class Flight extends Model</p><p>{</p><p>/**</p><p> * Indicates if the model's ID is auto-incrementing.</p><p> *</p><p> * @var bool</p><p>*/</p><p>public $incrementing = false;</p><p>}</p><p>If your model's primary key is not an integer, you should define a protected <code>$keyType</code> property on your model. This property should have a value of <code>string</code>:</p><pre><code>&lt;?php</code></pre><p>&nbsp;</p><p>class Flight extends Model</p><p>{</p><p>/**</p><p> * The data type of the auto-incrementing ID.</p><p> *</p><p> * @var string</p><p>*/</p><p>protected $keyType = 'string';</p><p>}</p><p></p><h4><a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#composite-primary-keys"><strong>"Composite" Primary Keys</strong></a></h4><p>Eloquent requires each model to have at least one uniquely identifying "ID" that can serve as its primary key. "Composite" primary keys are not supported by Eloquent models. However, you are free to add additional multi-column, unique indexes to your database tables in addition to the table's uniquely identifying primary key.</p><p></p><h3><a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#uuid-and-ulid-keys"><strong>UUID &amp; ULID Keys</strong></a></h3><p>Instead of using auto-incrementing integers as your Eloquent model's primary keys, you may choose to use UUIDs instead. UUIDs are universally unique alpha-numeric identifiers that are 36 characters long.</p><p>If you would like a model to use a UUID key instead of an auto-incrementing integer key, you may use the <code>Illuminate\\Database\\Eloquent\\Concerns\\HasUuids</code> trait on the model. Of course, you should ensure that the model has a <a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/migrations#column-method-uuid">UUID equivalent primary key column</a>:</p><pre><code>use Illuminate\\Database\\Eloquent\\Concerns\\HasUuids;</code></pre><p>use Illuminate\\Database\\Eloquent\\Model;</p><p>&nbsp;</p><p>class Article extends Model</p><p>{</p><p>use HasUuids;</p><p>&nbsp;</p><p>// ...</p><p>}</p><p>&nbsp;</p><p>$article = Article::create(['title' =&gt; 'Traveling to Europe']);</p><p>&nbsp;</p><p>$article-&gt;id; // "8f8e8478-9035-4d23-b9a7-62f4d2612ce5"</p><p>By default, The <code>HasUuids</code> trait will generate <a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/helpers#method-str-ordered-uuid">"ordered" UUIDs</a> for your models. These UUIDs are more efficient for indexed database storage because they can be sorted lexicographically.</p><p>You can override the UUID generation process for a given model by defining a <code>newUniqueId</code> method on the model. In addition, you may specify which columns should receive UUIDs by defining a <code>uniqueIds</code> method on the model:</p><pre><code>use Ramsey\\Uuid\\Uuid;</code></pre><p>&nbsp;</p><p>/**</p><p> * Generate a new UUID for the model.</p><p>*/</p><p>public function newUniqueId(): string</p><p>{</p><p>return (string) Uuid::uuid4();</p><p>}</p><p>&nbsp;</p><p>/**</p><p> * Get the columns that should receive a unique identifier.</p><p> *</p><p> * @return array&lt;int, string&gt;</p><p>*/</p><p>public function uniqueIds(): array</p><p>{</p><p>return ['id', 'discount_code'];</p><p>}</p><p>If you wish, you may choose to utilize "ULIDs" instead of UUIDs. ULIDs are similar to UUIDs; however, they are only 26 characters in length. Like ordered UUIDs, ULIDs are lexicographically sortable for efficient database indexing. To utilize ULIDs, you should use the <code>Illuminate\\Database\\Eloquent\\Concerns\\HasUlids</code> trait on your model. You should also ensure that the model has a <a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/migrations#column-method-ulid">ULID equivalent primary key column</a>:</p><pre><code>use Illuminate\\Database\\Eloquent\\Concerns\\HasUlids;</code></pre><p>use Illuminate\\Database\\Eloquent\\Model;</p><p>&nbsp;</p><p>class Article extends Model</p><p>{</p><p>use HasUlids;</p><p>&nbsp;</p><p>// ...</p><p>}</p><p>&nbsp;</p><p>$article = Article::create(['title' =&gt; 'Traveling to Asia']);</p><p>&nbsp;</p><p>$article-&gt;id; // "01gd4d3tgrrfqeda94gdbtdk5c"</p><p></p><h3><a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#timestamps"><strong>Timestamps</strong></a></h3><p>By default, Eloquent expects <code>created_at</code> and <code>updated_at</code> columns to exist on your model's corresponding database table. Eloquent will automatically set these column's values when models are created or updated. If you do not want these columns to be automatically managed by Eloquent, you should define a <code>$timestamps</code> property on your model with a value of <code>false</code>:</p><pre><code>&lt;?php</code></pre><p>&nbsp;</p><p>namespace App\\Models;</p><p>&nbsp;</p><p>use Illuminate\\Database\\Eloquent\\Model;</p><p>&nbsp;</p><p>class Flight extends Model</p><p>{</p><p>/**</p><p> * Indicates if the model should be timestamped.</p><p> *</p><p> * @var bool</p><p>*/</p><p>public $timestamps = false;</p><p>}</p><p>If you need to customize the format of your model's timestamps, set the <code>$dateFormat</code> property on your model. This property determines how date attributes are stored in the database as well as their format when the model is serialized to an array or JSON:</p><pre><code>&lt;?php</code></pre><p>&nbsp;</p><p>namespace App\\Models;</p><p>&nbsp;</p><p>use Illuminate\\Database\\Eloquent\\Model;</p><p>&nbsp;</p><p>class Flight extends Model</p><p>{</p><p>/**</p><p> * The storage format of the model's date columns.</p><p> *</p><p> * @var string</p><p>*/</p><p>protected $dateFormat = 'U';</p><p>}</p><p>If you need to customize the names of the columns used to store the timestamps, you may define <code>CREATED_AT</code> and <code>UPDATED_AT</code> constants on your model:</p><pre><code>&lt;?php</code></pre><p>&nbsp;</p><p>class Flight extends Model</p><p>{</p><p>const CREATED_AT = 'creation_date';</p><p>const UPDATED_AT = 'updated_date';</p><p>}</p><p>If you would like to perform model operations without the model having its <code>updated_at</code> timestamp modified, you may operate on the model within a closure given to the <code>withoutTimestamps</code> method:</p><pre><code>Model::withoutTimestamps(fn () =&gt; $post-&gt;increment(['reads']));</code></pre><p></p><h3><a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#database-connections"><strong>Database Connections</strong></a></h3><p>By default, all Eloquent models will use the default database connection that is configured for your application. If you would like to specify a different connection that should be used when interacting with a particular model, you should define a <code>$connection</code> property on the model:</p><pre><code>&lt;?php</code></pre><p>&nbsp;</p><p>namespace App\\Models;</p><p>&nbsp;</p><p>use Illuminate\\Database\\Eloquent\\Model;</p><p>&nbsp;</p><p>class Flight extends Model</p><p>{</p><p>/**</p><p> * The database connection that should be used by the model.</p><p> *</p><p> * @var string</p><p>*/</p><p>protected $connection = 'sqlite';</p><p>}</p><p></p><h3><a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#default-attribute-values"><strong>Default Attribute Values</strong></a></h3><p>By default, a newly instantiated model instance will not contain any attribute values. If you would like to define the default values for some of your model's attributes, you may define an <code>$attributes</code> property on your model. Attribute values placed in the <code>$attributes</code> array should be in their raw, "storable" format as if they were just read from the database:</p><pre><code>&lt;?php</code></pre><p>&nbsp;</p><p>namespace App\\Models;</p><p>&nbsp;</p><p>use Illuminate\\Database\\Eloquent\\Model;</p><p>&nbsp;</p><p>class Flight extends Model</p><p>{</p><p>/**</p><p> * The model's default values for attributes.</p><p> *</p><p> * @var array</p><p>*/</p><p>protected $attributes = [</p><p>'options' =&gt; '[]',</p><p>'delayed' =&gt; false,</p><p> ];</p><p>}</p><p></p><h3><a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#configuring-eloquent-strictness"><strong>Configuring Eloquent Strictness</strong></a></h3><p>Laravel offers several methods that allow you to configure Eloquent's behavior and "strictness" in a variety of situations.</p><p>First, the <code>preventLazyLoading</code> method accepts an optional boolean argument that indicates if lazy loading should be prevented. For example, you may wish to only disable lazy loading in non-production environments so that your production environment will continue to function normally even if a lazy loaded relationship is accidentally present in production code. Typically, this method should be invoked in the <code>boot</code> method of your application's <code>AppServiceProvider</code>:</p><pre><code>use Illuminate\\Database\\Eloquent\\Model;</code></pre><p>&nbsp;</p><p>/**</p><p> * Bootstrap any application services.</p><p>*/</p><p>public function boot(): void</p><p>{</p><p>Model::preventLazyLoading(! $this-&gt;app-&gt;isProduction());</p><p>}</p><p>Also, you may instruct Laravel to throw an exception when attempting to fill an unfillable attribute by invoking the <code>preventSilentlyDiscardingAttributes</code> method. This can help prevent unexpected errors during local development when attempting to set an attribute that has not been added to the model's <code>fillable</code> array:</p><pre><code>Model::preventSilentlyDiscardingAttributes(! $this-&gt;app-&gt;isProduction());</code></pre><p></p><h2><a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#retrieving-models">Retrieving Models</a></h2><p>Once you have created a model and <a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/migrations#writing-migrations">its associated database table</a>, you are ready to start retrieving data from your database. You can think of each Eloquent model as a powerful <a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/queries">query builder</a> allowing you to fluently query the database table associated with the model. The model's <code>all</code> method will retrieve all of the records from the model's associated database table:</p><pre><code>use App\\Models\\Flight;</code></pre><p>&nbsp;</p><p>foreach (Flight::all() as $flight) {</p><p>echo $flight-&gt;name;</p><p>}</p><p></p><h4><a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#building-queries"><strong>Building Queries</strong></a></h4><p>The Eloquent <code>all</code> method will return all of the results in the model's table. However, since each Eloquent model serves as a <a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/queries">query builder</a>, you may add additional constraints to queries and then invoke the <code>get</code> method to retrieve the results:</p><pre><code>$flights = Flight::where('active', 1)</code></pre><p>-&gt;orderBy('name')</p><p>-&gt;take(10)</p><p>-&gt;get();</p><blockquote><img src="https://laravel.com/img/callouts/lightbulb.min.svg"><p>Since Eloquent models are query builders, you should review all of the methods provided by Laravel's <a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/queries">query builder</a>. You may use any of these methods when writing your Eloquent queries.</p></blockquote><p></p><h4><a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#refreshing-models"><strong>Refreshing Models</strong></a></h4><p>If you already have an instance of an Eloquent model that was retrieved from the database, you can "refresh" the model using the <code>fresh</code> and <code>refresh</code> methods. The <code>fresh</code> method will re-retrieve the model from the database. The existing model instance will not be affected:</p><pre><code>$flight = Flight::where('number', 'FR 900')-&gt;first();</code></pre><p>&nbsp;</p><p>$freshFlight = $flight-&gt;fresh();</p><p>The <code>refresh</code> method will re-hydrate the existing model using fresh data from the database. In addition, all of its loaded relationships will be refreshed as well:</p><pre><code>$flight = Flight::where('number', 'FR 900')-&gt;first();</code></pre><p>&nbsp;</p><p>$flight-&gt;number = 'FR 456';</p><p>&nbsp;</p><p>$flight-&gt;refresh();</p><p>&nbsp;</p><p>$flight-&gt;number; // "FR 900"</p><p></p><h3><a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#collections"><strong>Collections</strong></a></h3><p>As we have seen, Eloquent methods like <code>all</code> and <code>get</code> retrieve multiple records from the database. However, these methods don't return a plain PHP array. Instead, an instance of <code>Illuminate\\Database\\Eloquent\\Collection</code> is returned.</p><p>The Eloquent <code>Collection</code> class extends Laravel's base <code>Illuminate\\Support\\Collection</code> class, which provides a <a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/collections#available-methods">variety of helpful methods</a> for interacting with data collections. For example, the <code>reject</code> method may be used to remove models from a collection based on the results of an invoked closure:</p><pre><code>$flights = Flight::where('destination', 'Paris')-&gt;get();</code></pre><p>&nbsp;</p><p>$flights = $flights-&gt;reject(function (Flight $flight) {</p><p>return $flight-&gt;cancelled;</p><p>});</p><p>In addition to the methods provided by Laravel's base collection class, the Eloquent collection class provides <a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent-collections#available-methods">a few extra methods</a> that are specifically intended for interacting with collections of Eloquent models.</p><p>Since all of Laravel's collections implement PHP's iterable interfaces, you may loop over collections as if they were an array:</p><pre><code>foreach ($flights as $flight) {</code></pre><p>echo $flight-&gt;name;</p><p>}</p><p></p><h3><a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#chunking-results"><strong>Chunking Results</strong></a></h3><p>Your application may run out of memory if you attempt to load tens of thousands of Eloquent records via the <code>all</code> or <code>get</code> methods. Instead of using these methods, the <code>chunk</code> method may be used to process large numbers of models more efficiently.</p><p>The <code>chunk</code> method will retrieve a subset of Eloquent models, passing them to a closure for processing. Since only the current chunk of Eloquent models is retrieved at a time, the <code>chunk</code> method will provide significantly reduced memory usage when working with a large number of models:</p><pre><code>use App\\Models\\Flight;</code></pre><p>use Illuminate\\Database\\Eloquent\\Collection;</p><p>&nbsp;</p><p>Flight::chunk(200, function (Collection $flights) {</p><p>foreach ($flights as $flight) {</p><p>// ...</p><p> }</p><p>});</p><p>The first argument passed to the <code>chunk</code> method is the number of records you wish to receive per "chunk". The closure passed as the second argument will be invoked for each chunk that is retrieved from the database. A database query will be executed to retrieve each chunk of records passed to the closure.</p><p>If you are filtering the results of the <code>chunk</code> method based on a column that you will also be updating while iterating over the results, you should use the <code>chunkById</code> method. Using the <code>chunk</code> method in these scenarios could lead to unexpected and inconsistent results. Internally, the <code>chunkById</code> method will always retrieve models with an <code>id</code> column greater than the last model in the previous chunk:</p><pre><code>Flight::where('departed', true)</code></pre><p>-&gt;chunkById(200, function (Collection $flights) {</p><p>$flights-&gt;each-&gt;update(['departed' =&gt; false]);</p><p> }, $column = 'id');</p><p></p><h3><a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#chunking-using-lazy-collections"><strong>Chunking Using Lazy Collections</strong></a></h3><p>The <code>lazy</code> method works similarly to <a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#chunking-results">the </a><code>chunk</code> method in the sense that, behind the scenes, it executes the query in chunks. However, instead of passing each chunk directly into a callback as is, the <code>lazy</code> method returns a flattened <code>LazyCollection</code> of Eloquent models, which lets you interact with the results as a single stream:</p><pre><code>use App\\Models\\Flight;</code></pre><p>&nbsp;</p><p>foreach (Flight::lazy() as $flight) {</p><p>// ...</p><p>}</p><p>If you are filtering the results of the <code>lazy</code> method based on a column that you will also be updating while iterating over the results, you should use the <code>lazyById</code> method. Internally, the <code>lazyById</code> method will always retrieve models with an <code>id</code> column greater than the last model in the previous chunk:</p><pre><code>Flight::where('departed', true)</code></pre><p>-&gt;lazyById(200, $column = 'id')</p><p>-&gt;each-&gt;update(['departed' =&gt; false]);</p><p>You may filter the results based on the descending order of the <code>id</code> using the <code>lazyByIdDesc</code> method.</p><p></p><h3><a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#cursors"><strong>Cursors</strong></a></h3><p>Similar to the <code>lazy</code> method, the <code>cursor</code> method may be used to significantly reduce your application's memory consumption when iterating through tens of thousands of Eloquent model records.</p><p>The <code>cursor</code> method will only execute a single database query; however, the individual Eloquent models will not be hydrated until they are actually iterated over. Therefore, only one Eloquent model is kept in memory at any given time while iterating over the cursor.</p><blockquote><img src="https://laravel.com/img/callouts/exclamation.min.svg"><p>Since the <code>cursor</code> method only ever holds a single Eloquent model in memory at a time, it cannot eager load relationships. If you need to eager load relationships, consider using <a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#chunking-using-lazy-collections">the </a><code>lazy</code> method instead.</p></blockquote><p>Internally, the <code>cursor</code> method uses PHP <a target="_blank" rel="noopener noreferrer nofollow" href="https://www.php.net/manual/en/language.generators.overview.php">generators</a> to implement this functionality:</p><pre><code>use App\\Models\\Flight;</code></pre><p>&nbsp;</p><p>foreach (Flight::where('destination', 'Zurich')-&gt;cursor() as $flight) {</p><p>// ...</p><p>}</p><p>The <code>cursor</code> returns an <code>Illuminate\\Support\\LazyCollection</code> instance. <a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/collections#lazy-collections">Lazy collections</a> allow you to use many of the collection methods available on typical Laravel collections while only loading a single model into memory at a time:</p><pre><code>use App\\Models\\User;</code></pre><p>&nbsp;</p><p>$users = User::cursor()-&gt;filter(function (User $user) {</p><p>return $user-&gt;id &gt; 500;</p><p>});</p><p>&nbsp;</p><p>foreach ($users as $user) {</p><p>echo $user-&gt;id;</p><p>}</p><p>Although the <code>cursor</code> method uses far less memory than a regular query (by only holding a single Eloquent model in memory at a time), it will still eventually run out of memory. This is <a target="_blank" rel="noopener noreferrer nofollow" href="https://www.php.net/manual/en/mysqlinfo.concepts.buffering.php">due to PHP's PDO driver internally caching all raw query results in its buffer</a>. If you're dealing with a very large number of Eloquent records, consider using <a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#chunking-using-lazy-collections">the </a><code>lazy</code> method instead.</p><p></p><h3><a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#advanced-subqueries"><strong>Advanced Subqueries</strong></a></h3><p></p><h4><a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#subquery-selects"><strong>Subquery Selects</strong></a></h4><p>Eloquent also offers advanced subquery support, which allows you to pull information from related tables in a single query. For example, let's imagine that we have a table of flight <code>destinations</code> and a table of <code>flights</code> to destinations. The <code>flights</code> table contains an <code>arrived_at</code> column which indicates when the flight arrived at the destination.</p><p>Using the subquery functionality available to the query builder's <code>select</code> and <code>addSelect</code> methods, we can select all of the <code>destinations</code> and the name of the flight that most recently arrived at that destination using a single query:</p><pre><code>use App\\Models\\Destination;</code></pre><p>use App\\Models\\Flight;</p><p>&nbsp;</p><p>return Destination::addSelect(['last_flight' =&gt; Flight::select('name')</p><p>-&gt;whereColumn('destination_id', '<a target="_blank" rel="noopener noreferrer nofollow" href="http://destinations.id">destinations.id</a>')</p><p>-&gt;orderByDesc('arrived_at')</p><p>-&gt;limit(1)</p><p>])-&gt;get();</p><p></p><h4><a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#subquery-ordering"><strong>Subquery Ordering</strong></a></h4><p>In addition, the query builder's <code>orderBy</code> function supports subqueries. Continuing to use our flight example, we may use this functionality to sort all destinations based on when the last flight arrived at that destination. Again, this may be done while executing a single database query:</p><pre><code>return Destination::orderByDesc(</code></pre><p>Flight::select('arrived_at')</p><p>-&gt;whereColumn('destination_id', '<a target="_blank" rel="noopener noreferrer nofollow" href="http://destinations.id">destinations.id</a>')</p><p>-&gt;orderByDesc('arrived_at')</p><p>-&gt;limit(1)</p><p>)-&gt;get();</p><p></p><h2><a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#retrieving-single-models">Retrieving Single Models / Aggregates</a></h2><p>In addition to retrieving all of the records matching a given query, you may also retrieve single records using the <code>find</code>, <code>first</code>, or <code>firstWhere</code> methods. Instead of returning a collection of models, these methods return a single model instance:</p><pre><code>use App\\Models\\Flight;</code></pre><p>&nbsp;</p><p>// Retrieve a model by its primary key...</p><p>$flight = Flight::find(1);</p><p>&nbsp;</p><p>// Retrieve the first model matching the query constraints...</p><p>$flight = Flight::where('active', 1)-&gt;first();</p><p>&nbsp;</p><p>// Alternative to retrieving the first model matching the query constraints...</p><p>$flight = Flight::firstWhere('active', 1);</p><p>Sometimes you may wish to perform some other action if no results are found. The <code>findOr</code> and <code>firstOr</code> methods will return a single model instance or, if no results are found, execute the given closure. The value returned by the closure will be considered the result of the method:</p><pre><code>$flight = Flight::findOr(1, function () {</code></pre><p>// ...</p><p>});</p><p>&nbsp;</p><p>$flight = Flight::where('legs', '&gt;', 3)-&gt;firstOr(function () {</p><p>// ...</p><p>});</p><p></p><h4><a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#not-found-exceptions"><strong>Not Found Exceptions</strong></a></h4><p>Sometimes you may wish to throw an exception if a model is not found. This is particularly useful in routes or controllers. The <code>findOrFail</code> and <code>firstOrFail</code> methods will retrieve the first result of the query; however, if no result is found, an <code>Illuminate\\Database\\Eloquent\\ModelNotFoundException</code> will be thrown:</p><pre><code>$flight = Flight::findOrFail(1);</code></pre><p>&nbsp;</p><p>$flight = Flight::where('legs', '&gt;', 3)-&gt;firstOrFail();</p><p>If the <code>ModelNotFoundException</code> is not caught, a 404 HTTP response is automatically sent back to the client:</p><pre><code>use App\\Models\\Flight;</code></pre><p>&nbsp;</p><p>Route::get('/api/flights/{id}', function (string $id) {</p><p>return Flight::findOrFail($id);</p><p>});</p><p></p><h3><a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#retrieving-or-creating-models"><strong>Retrieving Or Creating Models</strong></a></h3><p>The <code>firstOrCreate</code> method will attempt to locate a database record using the given column / value pairs. If the model can not be found in the database, a record will be inserted with the attributes resulting from merging the first array argument with the optional second array argument:</p><p>The <code>firstOrNew</code> method, like <code>firstOrCreate</code>, will attempt to locate a record in the database matching the given attributes. However, if a model is not found, a new model instance will be returned. Note that the model returned by <code>firstOrNew</code> has not yet been persisted to the database. You will need to manually call the <code>save</code> method to persist it:</p><pre><code>use App\\Models\\Flight;</code></pre><p>&nbsp;</p><p>// Retrieve flight by name or create it if it doesn't exist...</p><p>$flight = Flight::firstOrCreate([</p><p>'name' =&gt; 'London to Paris'</p><p>]);</p><p>&nbsp;</p><p>// Retrieve flight by name or create it with the name, delayed, and arrival_time attributes...</p><p>$flight = Flight::firstOrCreate(</p><p> ['name' =&gt; 'London to Paris'],</p><p> ['delayed' =&gt; 1, 'arrival_time' =&gt; '11:30']</p><p>);</p><p>&nbsp;</p><p>// Retrieve flight by name or instantiate a new Flight instance...</p><p>$flight = Flight::firstOrNew([</p><p>'name' =&gt; 'London to Paris'</p><p>]);</p><p>&nbsp;</p><p>// Retrieve flight by name or instantiate with the name, delayed, and arrival_time attributes...</p><p>$flight = Flight::firstOrNew(</p><p> ['name' =&gt; 'Tokyo to Sydney'],</p><p> ['delayed' =&gt; 1, 'arrival_time' =&gt; '11:30']</p><p>);</p><p></p><h3><a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/eloquent#retrieving-aggregates"><strong>Retrieving Aggregates</strong></a></h3><p>When interacting with Eloquent models, you may also use the <code>count</code>, <code>sum</code>, <code>max</code>, and other <a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/queries#aggregates">aggregate methods</a> provided by the Laravel <a target="_blank" rel="noopener noreferrer nofollow" href="https://laravel.com/docs/10.x/queries">query builder</a>. As you might expect, these methods return a scalar value instead of an Eloquent model instance:</p><pre><code>$count = Flight::where('active', 1)-&gt;count();</code></pre><p>&nbsp;</p><p>$max = Flight::where('active', 1)-&gt;max('price');</p></body></html>

`)
  const [isOpen, setIsOpen] = useState(true)

  return (
    <VStack width={"full"} spacing={20} p={10} h={"full"} overflow={"hidden"}>
      <Heading>Hello</Heading>

      <NovelEditor
        value={value}
        setValue={setValue}
        mode={"html"}
        handleUpload={handleFileUpload}
        toastPosition={"top"}
        maxFileSize={10}
        rounded={"0"}
        // color={"red"}
        // bg={
        //   "linear-gradient(to bottom right, black 33%, darkblue 34%, purple 34%, purple 66%, darkblue 66%, black 67%, black 100%)"
        // }
        border={"1px solid"}
        _hover={{ borderColor: "lightblue" }}
        _active={{ borderColor: "red" }}
        shadow={"darkred 0px 22px 70px 4px;"}
        h={"500px"}
      />

      {/*<DrawerAddTicket isOpen={isOpen} onClose={() => setIsOpen(false)} />*/}

      {/*<TicketAnswerDescription />*/}
      <pre>{value}</pre>
    </VStack>
  )
}

export default App
